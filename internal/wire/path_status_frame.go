package wire

import (
	"bytes"
	"errors"
	"github.com/quic-go/quic-go/internal/protocol"
	"github.com/quic-go/quic-go/quicvarint"
)

/*
	Endpoints use PATH_STATUS frame to inform the peer whether it prefer
	to use this path or not. If an endpoint receives a PATH_STATUS frame
	containing 1-Standby status, it SHOULD stop sending non-probing
	packets on the corresponding path, until it receives a new
	PATH_STATUS frame containing 2-Available status with a higher
	sequence number referring to the same path.

	Frames may be received out of order. A peer MUST ignore an incoming
	PATH_STATUS frame if it previously received another PATH_STATUS
	frame for the same Destination Connection ID Sequence Number with a
	Path Status sequence number equal to or higher than the Path Status
	sequence number of the incoming frame.

	PATH_STATUS frames SHOULD be acknowledged. If a packet containing a
	PATH_STATUS frame is considered lost, the peer should only repeat it
	if it was the last status sent for that path -- as indicated by the
	sequence number.
*/

type PathStatusFrame struct {
	FrameType                             uint64
	DestinationConnectionIDSequenceNumber uint64 // The sequence number of the Destination Connection ID used by the receiver of this frame to send packets over the path the status update corresponds to.
	PathStatusSequenceNumber              uint64 // A variable-length integer specifying the sequence number assigned for this PATH_STATUS frame. The sequence number MUST be monotonically increasing generated by the sender of the PATH_STATUS frame in the same connection. The receiver of the PATH_STATUS frame needs to use and compare the sequence numbers separately for each Destination Connection ID Sequence Number.
	PathStatus                            uint64 // Available values of Path Status field are: 1: Standby, 2: Available

}

func parsePathStatusFrame(r *bytes.Reader, _ protocol.VersionNumber) (*PathStatusFrame, error) {
	frame := &PathStatusFrame{}
	frameType, err := quicvarint.Read(r)
	if err != nil {
		return nil, err
	}
	frame.FrameType = frameType

	desIDSeqNum, err := quicvarint.Read(r)
	if err != nil {
		return nil, err
	}
	frame.DestinationConnectionIDSequenceNumber = desIDSeqNum

	pathStatusSeqNum, err := quicvarint.Read(r)
	if err != nil {
		return nil, err
	}
	frame.PathStatusSequenceNumber = pathStatusSeqNum

	pathStatus, err := quicvarint.Read(r)
	if err != nil {
		return nil, err
	}
	if pathStatus < 1 || pathStatus > 2 {
		err = errors.New("invalid PathStatus")
		return nil, err
	}
	frame.PathStatus = pathStatus

	return frame, nil
}

func (f *PathStatusFrame) Append(b []byte, _ protocol.VersionNumber) ([]byte, error) {
	b = quicvarint.Append(b, pathStatusFrameType)
	b = quicvarint.Append(b, f.DestinationConnectionIDSequenceNumber)
	b = quicvarint.Append(b, f.PathStatusSequenceNumber)
	b = quicvarint.Append(b, f.PathStatus)
	return b, nil
}

// Length of a written frame
func (f *PathStatusFrame) Length(_ protocol.VersionNumber) protocol.ByteCount {
	return 1 + 8
}
